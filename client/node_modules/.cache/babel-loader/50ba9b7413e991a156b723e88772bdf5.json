{"remainingRequest":"/var/www/html/Jobs/DOAN-TT/client/node_modules/babel-loader/lib/index.js!/var/www/html/Jobs/DOAN-TT/client/src/helpers/restructure.js","dependencies":[{"path":"/var/www/html/Jobs/DOAN-TT/client/src/helpers/restructure.js","mtime":1573548264993},{"path":"/var/www/html/Jobs/DOAN-TT/client/node_modules/cache-loader/dist/cjs.js","mtime":1571633391755},{"path":"/var/www/html/Jobs/DOAN-TT/client/node_modules/babel-loader/lib/index.js","mtime":1571304325577}],"contextDependencies":[],"result":["var unflatten = function unflatten(arr) {\n  var tree = [],\n      mappedArr = {},\n      arrElem,\n      mappedElem; // First map the nodes of the array to an object -> create a hash table.\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    arrElem = arr[i];\n    mappedArr[arrElem.id] = arrElem;\n    mappedArr[arrElem.id]['children'] = [];\n  }\n\n  for (var id in mappedArr) {\n    if (mappedArr.hasOwnProperty(id)) {\n      mappedElem = mappedArr[id]; // If the element is not at the root level, add it to its parent array of children.\n\n      if (mappedElem.parent_id) {\n        mappedArr[mappedElem['parent_id']]['children'].push(mappedElem);\n      } // If the element is at the root level, add it to first level elements array.\n      else {\n          tree.push(mappedElem);\n        }\n    }\n  }\n\n  return tree;\n};\n\nexport var restructure = function restructure(data) {\n  return unflatten(data);\n};",{"version":3,"sources":["/var/www/html/Jobs/DOAN-TT/client/src/helpers/restructure.js"],"names":["unflatten","arr","tree","mappedArr","arrElem","mappedElem","i","len","length","id","hasOwnProperty","parent_id","push","restructure","data"],"mappings":"AAAA,IAAMA,SAAS,GAAG,SAAZA,SAAY,CAACC,GAAD,EAAS;AACzB,MAAIC,IAAI,GAAG,EAAX;AAAA,MACIC,SAAS,GAAG,EADhB;AAAA,MAEIC,OAFJ;AAAA,MAGIC,UAHJ,CADyB,CAMzB;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGN,GAAG,CAACO,MAAzB,EAAiCF,CAAC,GAAGC,GAArC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7CF,IAAAA,OAAO,GAAGH,GAAG,CAACK,CAAD,CAAb;AACAH,IAAAA,SAAS,CAACC,OAAO,CAACK,EAAT,CAAT,GAAwBL,OAAxB;AACAD,IAAAA,SAAS,CAACC,OAAO,CAACK,EAAT,CAAT,CAAsB,UAAtB,IAAoC,EAApC;AACD;;AAGD,OAAK,IAAIA,EAAT,IAAeN,SAAf,EAA0B;AACxB,QAAIA,SAAS,CAACO,cAAV,CAAyBD,EAAzB,CAAJ,EAAkC;AAChCJ,MAAAA,UAAU,GAAGF,SAAS,CAACM,EAAD,CAAtB,CADgC,CAEhC;;AACA,UAAIJ,UAAU,CAACM,SAAf,EAA0B;AACxBR,QAAAA,SAAS,CAACE,UAAU,CAAC,WAAD,CAAX,CAAT,CAAmC,UAAnC,EAA+CO,IAA/C,CAAoDP,UAApD;AACD,OAFD,CAGA;AAHA,WAIK;AACHH,UAAAA,IAAI,CAACU,IAAL,CAAUP,UAAV;AACD;AACF;AACF;;AACD,SAAOH,IAAP;AACD,CA5BD;;AA8BA,OAAO,IAAMW,WAAW,GAAG,SAAdA,WAAc,CAACC,IAAD,EAAU;AACnC,SAAOd,SAAS,CAACc,IAAD,CAAhB;AACD,CAFM","sourcesContent":["const unflatten = (arr) => {\n  var tree = [],\n      mappedArr = {},\n      arrElem,\n      mappedElem;\n\n  // First map the nodes of the array to an object -> create a hash table.\n  for(var i = 0, len = arr.length; i < len; i++) {\n    arrElem = arr[i];\n    mappedArr[arrElem.id] = arrElem;\n    mappedArr[arrElem.id]['children'] = [];\n  }\n\n\n  for (var id in mappedArr) {\n    if (mappedArr.hasOwnProperty(id)) {\n      mappedElem = mappedArr[id];\n      // If the element is not at the root level, add it to its parent array of children.\n      if (mappedElem.parent_id) {\n        mappedArr[mappedElem['parent_id']]['children'].push(mappedElem);\n      }\n      // If the element is at the root level, add it to first level elements array.\n      else {\n        tree.push(mappedElem);\n      }\n    }\n  }\n  return tree;\n}\n\nexport const restructure = (data) => {\n  return unflatten(data);\n}\n\n"]}]}